---
title: MetadataDetector API
description: API reference for the MetadataDetector class - automatic media metadata extraction and management
icon: FileSearch
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# MetadataDetector API Reference

The `MetadataDetector` class provides intelligent metadata extraction from media files, automatic title generation, and smart tag suggestions for bookmarks.

## üîç Class Overview

```typescript
export class MetadataDetector {
  private deps: IINADependencies;
  private cache: Map<string, CachedMetadata>;
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  
  constructor(dependencies: IINADependencies);
}
```

<Callout type="info" title="Integration Point">
  The MetadataDetector integrates with IINA's core APIs to extract **rich metadata** from media files, including duration, resolution, codec information, and embedded metadata like title and description.
</Callout>

## üìã Core Methods

<Tabs items={['Metadata Extraction', 'Title Generation', 'Tag Suggestions', 'Cache Management']}>
  <Tab value="Metadata Extraction">
    ### Media Metadata Extraction
    
    #### `detectMetadata()`
    
    Extracts comprehensive metadata from the currently loaded media file.
    
    ```typescript
    async detectMetadata(filePath?: string): Promise<MediaMetadata>
    ```
    
    **Parameters:**
    - `filePath` (optional): Specific file path to analyze. If not provided, uses currently loaded media.
    
    **Returns:** `MediaMetadata` object with comprehensive file information.
    
    **Example Usage:**
    ```typescript
    const metadataDetector = new MetadataDetector(iinaDepencies);
    
    // Detect metadata for current media
    const metadata = await metadataDetector.detectMetadata();
    console.log(`Duration: ${metadata.duration}s`);
    console.log(`Resolution: ${metadata.resolution?.width}x${metadata.resolution?.height}`);
    
    // Detect metadata for specific file
    const fileMetadata = await metadataDetector.detectMetadata('/path/to/movie.mp4');
    ```
    
    **Metadata Properties:**
    ```typescript
    interface MediaMetadata {
      // Basic file information
      filename: string;              // Base filename without path
      filepath: string;              // Absolute file path
      fileSize: number;             // File size in bytes
      mediaType: string;            // MIME type or file extension
      
      // Media properties
      duration: number;             // Total duration in seconds
      resolution?: {                // Video resolution
        width: number;
        height: number;
      };
      bitrate?: number;             // Average bitrate in kbps
      frameRate?: number;           // Video frame rate (fps)
      
      // Audio/video tracks
      audioTracks: number;          // Number of audio streams
      subtitleTracks: number;       // Number of subtitle streams
      videoTracks: number;          // Number of video streams
      
      // Embedded metadata
      embeddedTitle?: string;       // Title from file metadata
      embeddedDescription?: string; // Description from file metadata
      embeddedTags?: string[];      // Tags from file metadata
      
      // Technical details
      codec?: {
        video?: string;             // Video codec (e.g., "H.264", "HEVC")
        audio?: string;             // Audio codec (e.g., "AAC", "AC3")
      };
      
      // Creation/modification dates
      createdAt?: string;           // File creation date (ISO 8601)
      modifiedAt?: string;          // File modification date (ISO 8601)
    }
    ```
    
    **Error Handling:**
    - **File not found**: Throws `FileNotFoundError`
    - **Access denied**: Throws `PermissionError`  
    - **Unsupported format**: Returns partial metadata with warnings
    - **Corrupted file**: Attempts best-effort extraction
    
    ---
    
    #### `refreshMetadata()`
    
    Forces a refresh of cached metadata for the current media file.
    
    ```typescript
    async refreshMetadata(): Promise<void>
    ```
    
    **Usage:**
    ```typescript
    // Refresh metadata cache (e.g., after file changes)
    await metadataDetector.refreshMetadata();
    ```
    
    **Behavior:**
    - Clears cached metadata for current file
    - Re-extracts all metadata properties
    - Updates bookmark manager's cached values
    - Triggers UI refresh if needed
  </Tab>
  
  <Tab value="Title Generation">
    ### Intelligent Title Generation
    
    #### `generateTitle()`
    
    Generates a smart title for bookmarks based on available metadata and context.
    
    ```typescript
    generateTitle(
      timestamp?: number,
      customContext?: TitleContext
    ): Promise<string>
    ```
    
    **Parameters:**
    - `timestamp`: Playback position for context-aware titles
    - `customContext`: Additional context for title generation
    
    **Title Generation Strategy:**
    
    <Steps>
      <Step>
        **Embedded Metadata Check**
        
        First attempts to use embedded title from media metadata
        ```typescript
        if (metadata.embeddedTitle) {
          return metadata.embeddedTitle;
        }
        ```
      </Step>
      
      <Step>
        **Filename Processing**
        
        Cleans and normalizes filename for readability
        ```typescript
        // Remove common patterns
        const cleaned = filename
          .replace(/\.(mp4|mkv|avi|mov)$/i, '')  // Remove extensions
          .replace(/[\._\-]/g, ' ')              // Replace separators
          .replace(/\d{4}/g, '')                 // Remove years
          .replace(/\b(720p|1080p|4K|HD)\b/gi, '') // Remove quality indicators
          .trim();
        ```
      </Step>
      
      <Step>
        **Context Enhancement**
        
        Adds timestamp-based context when appropriate
        ```typescript
        if (timestamp && metadata.duration) {
          const percentage = (timestamp / metadata.duration) * 100;
          if (percentage < 10) return `${baseTitle} - Opening`;
          if (percentage > 90) return `${baseTitle} - Ending`;
          if (percentage > 45 && percentage < 55) return `${baseTitle} - Midpoint`;
        }
        ```
      </Step>
    </Steps>
    
    **Title Context Interface:**
    ```typescript
    interface TitleContext {
      sceneType?: 'opening' | 'ending' | 'credits' | 'midpoint' | 'climax';
      chapterInfo?: {
        number: number;
        title?: string;
      };
      userHint?: string;         // User-provided context
      previousBookmarks?: BookmarkData[]; // For sequential numbering
    }
    ```
    
    **Example Outputs:**
    ```typescript
    // Original filename: "The.Matrix.1999.1080p.BluRay.x264.mp4"
    await generateTitle(); 
    // Result: "The Matrix"
    
    // With timestamp context
    await generateTitle(150); // 2.5 minutes into film
    // Result: "The Matrix - Opening"
    
    // With custom context
    await generateTitle(5420, { sceneType: 'climax' });
    // Result: "The Matrix - Climax Scene"
    ```
  </Tab>
  
  <Tab value="Tag Suggestions">
    ### Smart Tag Generation
    
    #### `generateTags()`
    
    Generates intelligent tag suggestions based on media metadata and content analysis.
    
    ```typescript
    generateTags(
      metadata?: MediaMetadata,
      existingBookmarks?: BookmarkData[]
    ): Promise<string[]>
    ```
    
    **Tag Generation Sources:**
    
    <Card title="Content Analysis" icon="Search">
      **File-based Tags**
      - Genre detection from filename patterns
      - Quality indicators (HD, 4K, etc.)
      - Format information (mp4, mkv, etc.)
      - Year extraction from filename
    </Card>
    
    <Card title="Technical Metadata" icon="Settings">
      **Media Properties**
      - Resolution-based tags (`4K`, `HD`, `SD`)
      - Audio quality (`Surround`, `Stereo`)
      - Codec information (`HEVC`, `H264`)
      - HDR capability detection
    </Card>
    
    <Card title="Contextual Tags" icon="Tag">
      **Smart Context**
      - Duration-based categories (`Short`, `Feature`)
      - Timestamp-based positioning (`Opening`, `Ending`)
      - Sequential numbering for series
      - User pattern learning
    </Card>
    
    **Tag Categories:**
    ```typescript
    interface TagCategories {
      technical: string[];      // "4K", "HDR", "Surround"
      content: string[];        // "Action", "Drama", "Documentary"
      context: string[];        // "Opening", "Climax", "Credits"
      temporal: string[];       // "2023", "Recent", "Classic"
      quality: string[];        // "HD", "BluRay", "Remaster"
      custom: string[];         // User-defined tags
    }
    ```
    
    **Example Tag Generation:**
    ```typescript
    // For: "Avengers.Endgame.2019.2160p.4K.UHD.BluRay.x265-TERMINAL.mkv"
    const tags = await metadataDetector.generateTags(metadata);
    // Result: ["4K", "2019", "BluRay", "Action", "Marvel", "HEVC"]
    
    // For bookmark at 45% progress
    const contextTags = await metadataDetector.generateTags(metadata, existingBookmarks);
    // Result: ["Midpoint", "Main Plot", "Character Development"]
    ```
    
    #### `suggestTags()`
    
    Provides real-time tag suggestions as user types.
    
    ```typescript
    suggestTags(
      partial: string,
      existingTags: string[],
      limit: number = 10
    ): Promise<string[]>
    ```
    
    **Features:**
    - **Auto-completion**: Suggests based on partial input
    - **Fuzzy matching**: Handles typos and variations
    - **Learning**: Adapts to user's tagging patterns
    - **Deduplication**: Excludes already-applied tags
    
    **Example:**
    ```typescript
    // User types "act"
    const suggestions = await metadataDetector.suggestTags("act", currentTags);
    // Result: ["action", "actor", "actual", "activity"]
    ```
  </Tab>
  
  <Tab value="Cache Management">
    ### Performance & Caching
    
    #### Cache System
    
    The MetadataDetector implements intelligent caching to minimize file I/O and improve performance.
    
    ```typescript
    interface CachedMetadata {
      metadata: MediaMetadata;
      timestamp: number;        // Cache creation time
      hits: number;            // Number of cache hits
      fileHash?: string;       // File content hash for validation
    }
    ```
    
    **Cache Features:**
    - **TTL-based expiration**: 5-minute default cache lifetime
    - **File change detection**: Invalidates cache on file modification
    - **LRU eviction**: Removes least recently used entries
    - **Memory management**: Configurable cache size limits
    
    #### `getCacheStats()`
    
    Returns cache performance statistics for monitoring and optimization.
    
    ```typescript
    getCacheStats(): CacheStatistics
    ```
    
    **Statistics Interface:**
    ```typescript
    interface CacheStatistics {
      totalEntries: number;     // Current cache entries
      hitRate: number;         // Cache hit rate (0-1)
      totalHits: number;       // Total cache hits
      totalMisses: number;     // Total cache misses
      averageAge: number;      // Average cache entry age (ms)
      memoryUsage: number;     // Estimated memory usage (bytes)
      
      // Per-file statistics
      fileStats: Array<{
        filepath: string;
        hits: number;
        lastAccessed: number;
        cacheAge: number;
      }>;
    }
    ```
    
    #### Cache Management Methods
    
    ```typescript
    // Clear all cached metadata
    clearCache(): void;
    
    // Clear cache for specific file
    clearFileCache(filePath: string): void;
    
    // Validate and cleanup expired entries
    cleanupCache(): void;
    
    // Pre-populate cache for known files
    warmupCache(filePaths: string[]): Promise<void>;
    ```
    
    **Usage Examples:**
    ```typescript
    // Monitor cache performance
    const stats = metadataDetector.getCacheStats();
    console.log(`Cache hit rate: ${(stats.hitRate * 100).toFixed(1)}%`);
    
    // Clear cache when needed
    if (stats.memoryUsage > MAX_CACHE_SIZE) {
      metadataDetector.cleanupCache();
    }
    
    // Warm up cache for playlist
    const playlistFiles = ['/movie1.mp4', '/movie2.mkv', '/movie3.mp4'];
    await metadataDetector.warmupCache(playlistFiles);
    ```
  </Tab>
</Tabs>

## üõ†Ô∏è Advanced Features

### File Format Support

<Cards>
  <Card title="Video Formats" icon="Video">
    **Fully Supported:**
    - MP4, MKV, AVI, MOV, WMV
    - WebM, FLV, M4V, 3GP
    - VOB, TS, M2TS
    
    **Metadata Available:**
    - Embedded titles/descriptions
    - Chapter information
    - Video/audio codec details
    - Resolution and frame rate
  </Card>
  
  <Card title="Audio Formats" icon="Music">
    **Fully Supported:**
    - MP3, FLAC, AAC, OGG
    - M4A, WMA, WAV, AIFF
    - APE, DSD, MQA
    
    **Metadata Available:**
    - ID3 tags (title, artist, album)
    - Embedded artwork
    - Audio quality metrics
    - Duration and bitrate
  </Card>
  
  <Card title="Streaming Formats" icon="Globe">
    **Supported:**
    - HLS (m3u8) streams
    - DASH manifests
    - Live streams
    - Network URLs
    
    **Limitations:**
    - Limited embedded metadata
    - Dynamic duration handling
    - Network-dependent extraction
  </Card>
</Cards>

### Error Handling & Fallbacks

```typescript
// Robust metadata extraction with fallbacks
try {
  const metadata = await metadataDetector.detectMetadata();
  return metadata;
} catch (error) {
  if (error instanceof FileNotFoundError) {
    // Handle missing file
    return getDefaultMetadata(filePath);
  } else if (error instanceof PermissionError) {
    // Handle access issues
    return getBasicFileInfo(filePath);
  } else if (error instanceof UnsupportedFormatError) {
    // Handle unknown formats
    return getFileSystemMetadata(filePath);
  } else {
    // Handle unexpected errors
    console.error('Metadata extraction failed:', error);
    return getFallbackMetadata(filePath);
  }
}
```

### Performance Optimization Tips

<Callout type="tip" title="Best Practices">
  1. **Pre-warm cache** for known files to improve responsiveness
  2. **Monitor cache hit rates** and adjust TTL based on usage patterns
  3. **Use batch operations** for multiple files to reduce overhead
  4. **Implement progressive loading** for large media collections
  5. **Cache tag suggestions** to improve typing responsiveness
</Callout>

## üéØ Integration Examples

### Basic Integration

```typescript
import { MetadataDetector } from './metadata-detector';
import { BookmarkManager } from './bookmark-manager';

// Initialize with IINA dependencies
const metadataDetector = new MetadataDetector({
  console: iina.console,
  core: iina.core,
  preferences: iina.preferences
});

// Use with bookmark creation
const bookmarkManager = new BookmarkManager({
  // ... dependencies
  metadataDetector
});

// Automatic metadata population
await bookmarkManager.addBookmark(); // Uses auto-detected title and tags
```

### Advanced Integration

```typescript
// Custom title generation with context
class AdvancedBookmarkManager extends BookmarkManager {
  async addContextualBookmark(sceneType: 'opening' | 'climax' | 'ending') {
    const currentTime = this.deps.core.status.time;
    const metadata = await this.metadataDetector.detectMetadata();
    
    const title = await this.metadataDetector.generateTitle(currentTime, {
      sceneType,
      previousBookmarks: this.getBookmarks()
    });
    
    const tags = await this.metadataDetector.generateTags(metadata);
    tags.push(sceneType); // Add context tag
    
    await this.addBookmark(title, currentTime, undefined, tags);
  }
}
```